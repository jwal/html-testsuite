<!DOCTYPE html>
<title>Canvas test: 2d.fillRule.nonzero</title>
<meta name="author" content="James Ascroft-Leigh">
<script src="../../common/canvas-tests.js"></script>
<link rel="stylesheet" href="../../common/canvas-tests.css">
<body class="show_output">

<h1><a href="index.2d.html">2d</a>.<a href="index.2d.fillRule.html">fillRule</a>.nonzero</h1>
<p class="desc"></p>

<div class="refs">Spec references:
<ul>
<li><a href="../annotated-spec/canvas.html#testrefs.2d.fillRule.nonzero">2d.fillRule.nonzero</a>
<li><a href="https://github.com/jwal/webkit/wiki/fillRule-specification">Draft specification</a></li>
</ul>
</div>
<p class="notes">
<p class="output">Actual output:</p>
<canvas id="c" class="output" width="426px" height="142px"><p class="fallback">FAIL (fallback content)</p></canvas>
<p class="output expectedtext">Expected output:<p><img src="2d.fillRule.nonzero.png" class="output expected" id="expected" alt="">
<ul id="d"></ul>
<script>
_addTest(function(canvas, ctx) {

// The test simply compares the rendered canvas image with the 
// expected PNG image.  Since the canvas->PNG->canvas->PNG conversion
// process (used for the expected result) can introduce some minor
// image differences (e.g. aliasing on the edges) we apply that same
// conversion to the actual rendered canvas before comparison.

var origstate = ctx.save();
ctx.fillRule = "nonzero";
_render_fillRule_example_shapes(ctx);
var rendered_canvas = document.getElementById("c");
var actual_canvas = document.createElement("canvas");
var actual_img = document.createElement("img");
actual_img.src = rendered_canvas.toDataURL("image/png");
actual_canvas.width = rendered_canvas.width;
actual_canvas.height = rendered_canvas.height;
actual_canvas.getContext("2d").drawImage(actual_img, 0, 0);
var expected_canvas = document.createElement("canvas");
expected_canvas.width = rendered_canvas.width;
expected_canvas.height = rendered_canvas.height;
expected_canvas.getContext("2d").drawImage(document.getElementById("expected"), 0, 0);
var actual_data = actual_canvas.toDataURL("image/png");
var expected_data = expected_canvas.toDataURL("image/png");
_assertEqual(actual_data, expected_data, "actual_data", "expected_data");

// Then look at some important points and assert they are filled or not as
// necessary.

var center_points = [
  [95, 75, "star"], // Center of star
  [227, 71, "circle"], // Center of middle circle
  [359, 71, "contra_circle"] // Center of right circle
];
var radiuss = [
  [55, "outside"], // Always outside the shape
  [25, "points"], // In the points of the star, alternating fill in star and always filled in the circles
  [10, "middle"] // In the middle, fill depends on the fillRule
];

function should_be_filled(fillRule, shape, orbit, k) {
  if (!(fillRule === "nonzero" || fillRule === "evenodd")) {
    throw new Error("Unknown fillRule: " + fillRule);
  }
  if (orbit === "outside") {
    return false;
  }
  if (orbit === "middle") {
    if (shape === "contra_circle") {
      return false;
    }
    if (fillRule === "evenodd") {
      return false;
    }
    return true;
  }
  if (orbit === "points") {
    if (shape === "star") {
      return (k % 2 === 0);
    }
    return true;
  }
  throw new Error("Don't know, sorry");
}

function circle_point(x, y) {
  ctx.restore(origstate);
  ctx.beginPath();
  ctx.strokeStyle = "green";
  ctx.arc(x, y, 3, 0, Math.PI*2, true);
  ctx.closePath();
  ctx.stroke();
}

function test_point(x, y, expected_fill) {
  var x = Math.floor(x);
  var y = Math.floor(y);
  var expected_fill_color = [255, 0, 0, 255];
  var red_index = 4 * x + 4 * img_width * y;
  if (expected_fill) {
    var actual = [];
    for (var i = 0; i < 4; i++) {
      actual.push(data[red_index + i]);
    }
    _assertEqual(JSON.stringify(actual), JSON.stringify(expected_fill_color), "actual", "expected_fill_color");
  } else {
    var actual_alpha = data[red_index + 3];
    _assertEqual(actual_alpha, 0, "actual_alpha", "0");
  }
}

var img_width = 1200;
var img_height = 800;
var data = ctx.getImageData(0, 0, img_width, img_height).data;
for (var i = 0; i < center_points.length; i++) {
  var center_x = center_points[i][0];
  var center_y = center_points[i][1];
  var shape = center_points[i][2];
  circle_point(center_x, center_y);
  
  for (var j = 0; j < radiuss.length; j++) {
    var radius = radiuss[j][0];
    var orbit = radiuss[j][1];
    var count = 10;
    for (var k = 0; k < count; k++) {
      var angle = k * ((2*Math.PI) / count);
      var x = center_x + (Math.sin(angle - Math.PI) * radius);
      var y = center_y + (Math.cos(angle - Math.PI) * radius);
      circle_point(x, y);
      console.log("nonzero", shape, orbit, k, should_be_filled("nonzero", shape, orbit, k));
      test_point(x, y, should_be_filled("nonzero", shape, orbit, k));
    }
  }
}

});
</script>

